# Tool Development Workflow

## Adding a New MCP Tool - Complete Checklist

### Step 1: Design the Tool

#### Questions to Answer
1. **What Unity operation does it perform?**
2. **What parameters does it need?**
3. **What should it return?**
4. **What errors can occur?**
5. **Does it need main thread execution?** (Usually yes)

#### Naming Convention
Format: `unity_{verb}_{noun}`

Examples:
- ✅ `unity_create_cube`
- ✅ `unity_delete_gameobject`
- ✅ `unity_get_scene_info`
- ✅ `unity_capture_screenshot`
- ❌ `unity_cube` (missing verb)
- ❌ `create_unity_cube` (wrong order)
- ❌ `unityCreateCube` (wrong format)

### Step 2: Implement in Unity (C#)

#### File: `MCPTools.cs`

**A. Add Switch Case**
```csharp
public static JObject Execute(string tool, JObject args)
{
    switch (tool)
    {
        // ... existing cases ...
        
        case "unity_your_tool_name":
            return YourToolName(args);
            
        default:
            throw new System.Exception($"Unknown tool: {tool}");
    }
}
```

**B. Implement Method**
```csharp
// Tool N: Description
private static JObject YourToolName(JObject args)
{
    // 1. Parse arguments with defaults
    string param1 = args["param1"]?.ToString() ?? "default";
    int param2 = args["param2"]?.ToObject<int>() ?? 10;
    bool param3 = args["param3"]?.ToObject<bool>() ?? false;
    
    // 2. Validate inputs (if needed)
    if (string.IsNullOrEmpty(param1))
    {
        return new JObject
        {
            ["success"] = false,
            ["error"] = "param1 is required"
        };
    }
    
    // 3. Execute Unity operations
    try
    {
        // Unity API calls here
        var result = DoUnityOperation();
        
        Debug.Log($"[MCP] ✅ Tool succeeded: {result}");
        
        return new JObject
        {
            ["success"] = true,
            ["data"] = result,
            ["message"] = "Operation completed successfully"
        };
    }
    catch (System.Exception e)
    {
        Debug.LogError($"[MCP] ❌ Tool failed: {e.Message}");
        
        return new JObject
        {
            ["success"] = false,
            ["error"] = $"Operation failed: {e.Message}"
        };
    }
}
```

**C. Return Value Guidelines**

Always include `success` field:
```csharp
// Success
{
    "success": true,
    "data": { /* actual data */ },
    "message": "optional success message"
}

// Failure
{
    "success": false,
    "error": "descriptive error message"
}
```

### Step 3: Implement in Python MCP Server

#### File: `unity_mcp_server.py`

**Add to TOOLS array:**
```python
{
    "name": "unity_your_tool_name",
    "description": "Clear description of what this tool does. Explain when AI should use it. Mark ESSENTIAL if critical.",
    "inputSchema": {
        "type": "object",
        "properties": {
            "param1": {
                "type": "string",
                "description": "What this parameter does",
                "default": "default_value"
            },
            "param2": {
                "type": "number",
                "description": "Numeric parameter with range",
                "default": 10,
                "minimum": 0,
                "maximum": 100
            },
            "param3": {
                "type": "boolean",
                "description": "Boolean flag",
                "default": false
            },
            "param4": {
                "type": "string",
                "enum": ["option1", "option2", "option3"],
                "description": "Limited choices",
                "default": "option1"
            }
        },
        "required": ["param1"]  # Only truly required params
    }
}
```

**Description Best Practices:**
- Start with clear action verb
- Explain what it does in one sentence
- Add when/why to use it
- Mark ESSENTIAL for critical tools
- Include usage hints for complex tools

**Parameter Best Practices:**
- Always provide defaults when sensible
- Document valid ranges and formats
- Use enums for limited choices
- Keep required params minimal
- Use descriptive names

### Step 4: Update Editor Window

#### File: `MCPServerWindow.cs`

Add to the help text:
```csharp
EditorGUILayout.HelpBox(
    "MCP Server is running!\n\n" +
    "Tools available:\n" +
    "- unity_ping\n" +
    "- unity_get_scene_info\n" +
    "- unity_create_cube\n" +
    "- unity_your_tool_name ⭐ NEW",  // Add your tool
    MessageType.Info
);
```

### Step 5: Test Manually

#### Test with curl
```bash
# Basic test
curl -X POST http://localhost:8765 \
  -H "Content-Type: application/json" \
  -d '{
    "tool": "unity_your_tool_name",
    "args": {
      "param1": "test"
    }
  }' | python3 -m json.tool

# Test with various parameters
curl -X POST http://localhost:8765 \
  -H "Content-Type: application/json" \
  -d '{
    "tool": "unity_your_tool_name",
    "args": {
      "param1": "test",
      "param2": 42,
      "param3": true
    }
  }' | python3 -m json.tool

# Test error case (invalid input)
curl -X POST http://localhost:8765 \
  -H "Content-Type: application/json" \
  -d '{
    "tool": "unity_your_tool_name",
    "args": {}
  }' | python3 -m json.tool
```

#### Test via Claude Desktop
1. Open Claude Desktop
2. Use the tool naturally in conversation
3. Verify it works as expected
4. Check Unity console for logs

#### Test During Compilation
1. Modify any Unity script
2. Wait for compilation to start
3. Call your tool (should queue and execute)
4. Verify server auto-restarts after compilation

### Step 6: Check Unity Logs

Use the self-debugging tool:
```bash
curl -X POST http://localhost:8765 \
  -H "Content-Type: application/json" \
  -d '{
    "tool": "unity_get_logs",
    "args": {
      "count": 20,
      "includeStackTrace": true
    }
  }' | python3 -m json.tool
```

Look for:
- ✅ `[MCP] ✅ Tool succeeded`
- ⚠️ Any warnings
- ❌ Any errors

### Step 7: Commit

```bash
git add .
git commit -m "feat: add unity_your_tool_name tool

- Implements [what it does]
- Parameters: param1, param2, param3
- Returns: [what it returns]
- Tested: [how you tested it]"

git push
```

## Common Patterns

### Pattern 1: Query Information
```csharp
private static JObject GetSomething(JObject args)
{
    // No parameters usually
    var info = CollectInformation();
    
    return new JObject
    {
        ["success"] = true,
        ["count"] = info.Count,
        ["items"] = info
    };
}
```

### Pattern 2: Create/Modify Objects
```csharp
private static JObject CreateSomething(JObject args)
{
    string name = args["name"]?.ToString() ?? "Default";
    
    var obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
    obj.name = name;
    
    return new JObject
    {
        ["success"] = true,
        ["name"] = obj.name,
        ["instanceId"] = obj.GetInstanceID()
    };
}
```

### Pattern 3: Operations with File Output
```csharp
private static JObject ExportSomething(JObject args)
{
    string path = args["path"]?.ToString();
    
    // Create default path if not provided
    if (string.IsNullOrEmpty(path))
    {
        path = Path.Combine(Application.dataPath, "..", "Temp", "export.data");
    }
    
    File.WriteAllBytes(path, data);
    
    return new JObject
    {
        ["success"] = true,
        ["path"] = Path.GetFullPath(path),
        ["fileSize"] = data.Length
    };
}
```

### Pattern 4: Async/Long Running Operations
```csharp
private static JObject WaitForSomething(JObject args)
{
    int maxWaitSeconds = args["maxWaitSeconds"]?.ToObject<int>() ?? 30;
    
    if (!IsOperationRunning())
    {
        return new JObject
        {
            ["success"] = true,
            ["message"] = "Operation not running, no wait needed",
            ["waitedSeconds"] = 0
        };
    }
    
    var startTime = System.DateTime.Now;
    
    while (IsOperationRunning())
    {
        System.Threading.Thread.Sleep(100);
        
        var elapsed = (System.DateTime.Now - startTime).TotalSeconds;
        if (elapsed >= maxWaitSeconds)
        {
            return new JObject
            {
                ["success"] = false,
                ["error"] = $"Timeout after {maxWaitSeconds} seconds",
                ["waitedSeconds"] = elapsed
            };
        }
    }
    
    var totalWait = (System.DateTime.Now - startTime).TotalSeconds;
    
    return new JObject
    {
        ["success"] = true,
        ["message"] = "Operation completed",
        ["waitedSeconds"] = totalWait
    };
}
```

## Tool Categories

### 1. Information Tools
- Read-only operations
- No side effects
- Fast execution
- Examples: `unity_get_scene_info`, `unity_is_compiling`, `unity_get_logs`

### 2. Creation Tools
- Create new GameObjects/assets
- Modify scene state
- Return created object info
- Examples: `unity_create_cube`, `unity_create_ui_canvas`

### 3. Modification Tools
- Change existing objects
- Take object reference + new values
- Return updated state
- Examples: `unity_set_transform`, `unity_set_color`

### 4. Deletion Tools
- Remove objects/components
- Confirm operation
- Handle not-found gracefully
- Examples: `unity_delete_gameobject`

### 5. Search Tools
- Find objects by criteria
- Return matches or empty array
- Support filtering
- Examples: `unity_find_gameobject`, `unity_list_objects`

### 6. Utility Tools
- Support operations
- Compilation, screenshots, logs
- Enable workflows
- Examples: `unity_capture_screenshot`, `unity_force_compile`

## Error Handling Checklist

- [ ] All Unity API calls in try-catch
- [ ] Helpful error messages for AI
- [ ] Log errors to Unity console
- [ ] Return structured error JSON
- [ ] Handle null/missing parameters
- [ ] Validate input ranges
- [ ] Check object exists before operating
- [ ] Provide recovery suggestions in errors

## Documentation Checklist

- [ ] XML doc comments on public methods
- [ ] Inline comments for complex logic
- [ ] Parameter descriptions in Python schema
- [ ] Usage examples in commit message
- [ ] Update README if significant feature
- [ ] Add to tool catalog docs

## Performance Checklist

- [ ] No blocking operations (or time-limited)
- [ ] Cleanup temporary objects
- [ ] Release unmanaged resources
- [ ] Cache when appropriate
- [ ] Consider memory for large data
- [ ] Optimize for AI iteration speed
